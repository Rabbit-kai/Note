### 关键字

#### const：

定义常量关键字

#### extern：

用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”；也就是说，在一个文件中定义了变量和函数， 在其他文件中要使用它们， 可以有两种方式：使用头文件，然后声明它们，然后其他文件去包含头文件；在其他文件中直接extern。

extern C作用

链接指示符extern C
    如果程序员希望调用其他程序设计语言尤其是C 写的函数，那么调用函数时必须告诉编译器使用不同的要求，例如当这样的函数被调用时函数名或参数排列的顺序可能不同，无论是C++函数调用它还是用其他语言写的函数调用它，程序员用链接指示符告诉编译器该函数是用其他的程序设计语言编写的，链接指示符有两种形式既可以是单一语句形式也可以是复合语句形式。
// 单一语句形式的链接指示符
extern "C" void exit(int);
// 复合语句形式的链接指示符
extern "C" {
int printf( const char* ... );
int scanf( const char* ... );
}
// 复合语句形式的链接指示符
extern "C" {
#include <cmath>
}

-- 错误示例

int main()
{
// 错误: 链接指示符不能出现在函数内
extern "C" double sqrt( double );

}

### vector

**vector：**分配的是动态空间，即：我们发现在声明vector容器的时候也可以不指定容器的大小，vector是随着元素的加入，空间自动扩展的。但是，我们必须要负责任的肯定vector分配的空间是连续的，也就是支持数组中的下标随机访问，实际上vector的实现机制是：预留一部分空间，而且预留空间的大小是按一定比率增长的，如果空间不够用的话，要保证连续，就必须重新new一片空间，然后将原有元素移动到新空间，同时预留新的空间（并且新分配的空间比原来分配的空间），最后将原来的那部分空间释放掉。这样预留空间的好处就是不用每次向vector中加元素都重新分配空间。

**1.1.vector容器的构造函数**

vector容器的声明方式主要包括一下几种：

------

**vector<Elem> v  ，**创建一个空的vector。

**vector <Elem> v1(v)  ，**复制一个vector。

**vector <Elem> v(n)  ，**创建一个vector，含有n个数据，数据均已缺省构造产生。

**vector <Elem> v(n, elem)  ，**创建一个含有n个elem拷贝的vector。

**vector <Elem> v(beg,end)  ，**创建一个以[beg;end)区间的vector。

**v.~ vector <Elem>()  ，**销毁所有数据，释放内存。

------

**1.2.vector中其他常用的函数用法**

------

**v.assign(beg,end)** , 将[beg; end)区间中的数据赋值给v。

**v.assign(n,elem)**  , 将n个elem的拷贝赋值给v。

**v.at(idx)**         , 传回索引idx所指的数据，如果idx越界，抛出out_of_range。

**v.begin()**        , 传回迭代器重的可一个数据。

**v.capacity()**      , 返回容器中数据个数。

**v.clear()**        , 移除容器中所有数据。

**v.empty()**       , 判断容器是否为空。

**v.end()**         , 指向迭代器中的最后一个数据地址。

**v.insert(pos,elem)**　　　　　　  在pos位置插入一个elem拷贝，**传回新数据位置**（位置指传回地址值）。

**v.insert(pos,n,elem)**　　　　　　在pos位置插入在[beg,end)区间的数据。**无返回值**。

**v.insert(pos,beg,end)**　　　　  在pos位置插入n个elem数据。**无返回值**。

**v.erase(pos)**　　　　　　　　　 删除pos位置的数据，传回**下一个数据的位置**。

**v.erase(beg,end)**　　　　　　　删除[beg,end)区间的数据，传回**下一个数据的位置。**

**v.capacity()** 　　　　返回容器中数据个数。

**v.size()**　　　　　　 返回容器中实际数据的个数。

**v.reserve()**　　　　　保留适当的容量。 

**v.resize(num)** 　　重新指定队列的长度。

**v.max_size()**   　返回容器中最大数据的数量。

**c.rbegin()**　　　　　　 传回一个逆向队列的第一个数据。

**c.rend()**　　　　　　  传回一个逆向队列的最后一个数据的下一个位置。

**c.pop_back()**　　　　 删除最后一个数据。

**c.push_back(elem)**  在尾部加入一个数据。

**c.front()**　　　　　　  传回地一个数据。

**c.back()** 　　　　　　  传回最后一个数据，不检查这个数据是否存在。

**c1.swap(c2)** 　　　　 将c1和c2元素互换。

**swap(c1,c2)**　　　　  同上操作。



